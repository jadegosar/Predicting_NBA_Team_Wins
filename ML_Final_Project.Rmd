---
title: "Predicting NBA Team Wins"
output: html_notebook
---

#####################################################
########## NBA Data Download & Preparation ##########
#####################################################

```{r}
install.packages('devtools')


```

```{r}
library('devtools')
```


```{r}
devtools::install_github("abresler/nbastatR")

library("nbastatR")
```

```{r}
# Scrape regular season data
reg_data <- as.data.frame(game_logs(seasons = 2020:2021))

# View data 
tail(reg_data)
```


```{r}
# Extract game data
games <- unique(reg_data[, c("yearSeason", "slugSeason", "dateGame", "idGame", "slugTeam", "slugOpponent", "outcomeGame")])

## Create team stats 

# Create data frame to store results
team_stats <- as.data.frame(matrix(NA, nrow = nrow(games), ncol = 17))
# Name result columns
names(team_stats) <- c("fgm", "fga", "fg3m", "fg3a", "fg2m",
                       "fg2a", "ftm", "fta", "oreb", "dreb",
                       "treb", "ast", "stl", "blk", "tov",
                       "pf", "pts")

for(i in 1:nrow(games)){
  # Extract info for game for that team
  temp <- reg_data[reg_data$yearSeason == games$yearSeason[i] &
                     reg_data$slugSeason == games$slugSeason[i] &
                     reg_data$idGame == games$idGame[i] &
                     reg_data$slugTeam == games$slugTeam[i],]
  # Calculate stats
  team_stats$fgm[i] <- sum(temp$fgm, na.rm = T)
  team_stats$fga[i] <- sum(temp$fga, na.rm = T)
  team_stats$fg3m[i] <- sum(temp$fg3m, na.rm = T)
  team_stats$fg3a[i] <- sum(temp$fg3a, na.rm = T)
  team_stats$fg2m[i] <- sum(temp$fg2m, na.rm =T)
  team_stats$fg2a[i] <- sum(temp$fg2a, na.rm = T)
  team_stats$ftm[i] <- sum(temp$ftm, na.rm = T)
  team_stats$fta[i] <- sum(temp$fta, na.rm = T)
  team_stats$oreb[i] <- sum(temp$oreb, na.rm = T)
  team_stats$dreb[i] <- sum(temp$dreb, na.rm = T)
  team_stats$treb[i] <- sum(temp$treb, na.rm = T)
  team_stats$ast[i] <- sum(temp$ast, na.rm =T)
  team_stats$blk[i] <- sum(temp$blk, na.rm =T)
  team_stats$stl[i] <- sum(temp$stl, na.rm =T)
  team_stats$tov[i] <- sum(temp$tov, na.rm = T)
  team_stats$pf[i] <- sum(temp$pf, na.rm = T)
  team_stats$pts[i] <- sum(temp$pts, na.rm =T)
}


dim(team_stats)

# View team stats
summary(team_stats)



```

```{r}
help(dplyr)
```


```{r}

library(dplyr)

player_df <- reg_data %>%
  select(-c(isWin, slugLeague, urlTeamSeasonLogo, urlPlayerStats, urlPlayerThumbnail, urlPlayerHeadshot, urlPlayerActionPhoto, urlPlayerPhoto, idTeam, slugMatchup, slugTeamLoser, slugTeamWinner, hasVideo)) %>%
  group_by(namePlayer, idGame, nameTeam) 

player_df

```




```{r}
# Joins stats and game info
team_game <- cbind.data.frame(games, team_stats)

# Convert date to days
# Day calculator
day_calc <- function(dates){
  x <- as.POSIXct(dates)
  return(floor(unclass(x)/86400))
}
# Add days to data
team_game$days <- day_calc(team_game$dateGame)


## Calculate previous offensive & defensive averages

# Create data frames to store results
team_1_off <- team_1_def <- team_2_off <- team_2_def <- 
  as.data.frame(matrix(NA, nrow = nrow(games), ncol = ncol(team_stats)))

# Name result columns
names(team_1_off) <- names(team_2_off) <- names(team_1_def) <- names(team_2_def) <- names(team_stats)

# Loop through to calculate past averages
for(i in 1:nrow(games)){
  # Extract previous games for team 1 offense
  temp_1 <- team_game[team_game$slugSeason == team_game$slugSeason[i] &
                        team_game$slugTeam == team_game$slugTeam[i] &
                        team_game$days < team_game$days[i],]
  # If any exist
  if(nrow(temp_1) > 0){
    # Calculate previous averages
    team_1_off[i, c("fgm", "fga", "fg3m", "fg3a", "fg2m",
                    "fg2a", "ftm", "fta", "oreb", "dreb",
                    "treb", "ast", "stl", "blk", "tov",
                    "pf", "pts")] <- colMeans(temp_1[, c("fgm", "fga", "fg3m", "fg3a", "fg2m",
                                                         "fg2a", "ftm", "fta", "oreb", "dreb",
                                                         "treb", "ast", "stl", "blk", "tov",
                                                         "pf", "pts")], na.rm = T)
  }
  
  # Extract previous games for team 1 defense
  temp_2 <- team_game[team_game$slugSeason == team_game$slugSeason[i] &
                        team_game$slugOpponent == team_game$slugTeam[i] &
                        team_game$days < team_game$days[i],]
  # If any exist
  if(nrow(temp_2) > 0){
    # Calculate past defensive averages
    team_1_def[i, c("fgm", "fga", "fg3m", "fg3a", "fg2m",
                    "fg2a", "ftm", "fta", "oreb", "dreb",
                    "treb", "ast", "stl", "blk", "tov",
                    "pf", "pts")] <- colMeans(temp_2[, c("fgm", "fga", "fg3m", "fg3a", "fg2m",
                                                         "fg2a", "ftm", "fta", "oreb", "dreb",
                                                         "treb", "ast", "stl", "blk", "tov",
                                                         "pf", "pts")], na.rm = T)
  }
  
  # Extract previous games for team 2 offense
  temp_3 <- team_game[team_game$slugSeason == team_game$slugSeason[i] &
                        team_game$slugTeam == team_game$slugOpponent[i] &
                        team_game$days < team_game$days[i],]
  # If any exist
  if(nrow(temp_3) > 0){
    # Calculate past averages
    team_2_off[i, c("fgm", "fga", "fg3m", "fg3a", "fg2m",
                    "fg2a", "ftm", "fta", "oreb", "dreb",
                    "treb", "ast", "stl", "blk", "tov",
                    "pf", "pts")] <- colMeans(temp_3[, c("fgm", "fga", "fg3m", "fg3a", "fg2m",
                                                         "fg2a", "ftm", "fta", "oreb", "dreb",
                                                         "treb", "ast", "stl", "blk", "tov",
                                                         "pf", "pts")], na.rm = T)
  }
  
  # Extract previous games for team 2 defense
  temp_4 <- team_game[team_game$slugSeason == team_game$slugSeason[i] &
                        team_game$slugOpponent == team_game$slugOpponent[i] &
                        team_game$days < team_game$days[i],]
  # If any exist
  if(nrow(temp_4) > 0){
    # Calculate past averages
    team_2_def[i, c("fgm", "fga", "fg3m", "fg3a", "fg2m",
                    "fg2a", "ftm", "fta", "oreb", "dreb",
                    "treb", "ast", "stl", "blk", "tov",
                    "pf", "pts")] <- colMeans(temp_4[, c("fgm", "fga", "fg3m", "fg3a", "fg2m",
                                                         "fg2a", "ftm", "fta", "oreb", "dreb",
                                                         "treb", "ast", "stl", "blk", "tov",
                                                         "pf", "pts")], na.rm = T)
  }
  
}


# Calculate pctfg, pctfg2 pctfg3, pctft
team_1_off$pctfg <- team_1_off$fgm/team_1_off$fga
team_1_off$pctfg2 <- team_1_off$fg2m/team_1_off$fg2a
team_1_off$pctfg3 <- team_1_off$fg3m/team_1_off$fg3a
team_1_off$pctft <- team_1_off$ftm/team_1_off$fta

team_2_off$pctfg <- team_2_off$fgm/team_2_off$fga
team_2_off$pctfg2 <- team_2_off$fg2m/team_2_off$fg2a
team_2_off$pctfg3 <- team_2_off$fg3m/team_2_off$fg3a
team_2_off$pctft <- team_2_off$ftm/team_2_off$fta

team_1_def$pctfg <- team_1_def$fgm/team_1_def$fga
team_1_def$pctfg2 <- team_1_def$fg2m/team_1_def$fg2a
team_1_def$pctfg3 <- team_1_def$fg3m/team_1_def$fg3a
team_1_def$pctft <- team_1_def$ftm/team_1_def$fta

team_2_def$pctfg <- team_2_def$fgm/team_2_def$fga
team_2_def$pctfg2 <- team_2_def$fg2m/team_2_def$fg2a
team_2_def$pctfg3 <- team_2_def$fg3m/team_2_def$fg3a
team_2_def$pctft <- team_2_def$ftm/team_2_def$fta

# Give correct names
names(team_1_off) <- paste(names(team_1_off), "_1_off", sep = "")
names(team_2_off) <- paste(names(team_2_off), "_2_off", sep = "")
names(team_1_def) <- paste(names(team_1_def), "_1_def", sep = "")
names(team_2_def) <- paste(names(team_2_def), "_2_def", sep = "")

# Join into results data frame
game_data <- cbind.data.frame(games, team_1_off, team_1_def, team_2_off, team_2_def)

# Add points scored for each team
team_1_points <- team_2_points <- rep(NA, nrow(game_data))

for(i in 1:nrow(game_data)){
  team_1_points[i] <- team_game$pts[team_game$slugSeason == team_game$slugSeason[i] &
                                      team_game$dateGame == team_game$dateGame[i] &
                                      team_game$slugTeam == team_game$slugTeam[i]]
  team_2_points[i] <- team_game$pts[team_game$slugSeason == team_game$slugSeason[i] &
                                      team_game$dateGame == team_game$dateGame[i] &
                                      team_game$slugTeam == team_game$slugOpponent[i]]
}

game_data$team_1_points <- team_1_points
game_data$team_2_points <- team_2_points

```


```{r}
tail(game_data, 15)
```

```{r}
summary(game_data[,-c(1:7)])
```

```{r}
library(ggplot2)
```



```{r}

g_1 <- ggplot(game_data, aes(x = team_1_points, fill = outcomeGame)) + # Set x as mean smoothness and fill as diagnosis
  geom_density(alpha = 0.5) + # Select density plot and set transperancy (alpha)
    theme_set(theme_bw(base_size = 22) ) + # Set theme and text size
  theme(panel.grid.major = element_blank(), # Remove grid
        panel.grid.minor = element_blank(), # Remove grid
        panel.border = element_blank(), # Remove grid
        panel.background = element_blank()) + # Remove grid 
  labs(x = "Points Scored", title = "Points Scored by Outcome",
       fill = "Outcome") + # Set labels
  scale_fill_manual(values = c("W" = "green", "L" = "tomato"), # Set fill colors manually
                    labels = c("W" = "Win", "L" = "Loss")) # Set labels for fill
g_1 # Generate plot
```

Obviously, winning teams will display higher average point totals, but this visualization shows us that winning teams are concentrated around 120 points while losing teams usually score around 100 points.

```{r}
g2 <- ggplot(game_data,
              aes(x = tov_1_off,
                  y = ast_1_off,
                  color = outcomeGame)) +
  geom_point(alpha = 0.8) +
  labs(x = "Turnovers", y = "Assists", color = "Outcome", # Set labels
       title = "Turnovers vs. Assists") +
  theme(panel.grid.major = element_blank(), # Remove grid
        panel.grid.minor = element_blank(), # Remove grid
        panel.border = element_blank(), # Remove grid
        panel.background = element_blank()) # Remove grid
g2


```

```{r}
# Dimensions of dataset

dim(game_data)

help("sample")
```
```{r}
4278*.9
```



Player Replacement Model

```{r}
# Calcualte days
day_calc <- function(dates){
  x <- as.POSIXct(dates)
  return(floor(unclass(x)/86400))
}
# Add days to player data
reg_data$days <- day_calc(reg_data$dateGame)
# Create data frames to store results
off <- def <-  as.data.frame(matrix(NA, nrow = nrow(reg_data), ncol = 23))
names(off) <- names(def) <- c("fgm", "fga", "fg3m", "fg3a", "fg2m",
                       "fg2a", "ftm", "fta", "oreb", "dreb",
                       "treb", "ast", "stl", "blk", "tov",
                       "pf", "pts", "pctfg", "pctfg2", "pctfg3",
                       "pctft", "mins", "games")




# Loop through to calculate past averages
for(i in 1:nrow(reg_data)){
  print(i)
  # Extract previous games for player offense
  temp_1 <- reg_data[reg_data$slugSeason == reg_data$slugSeason[i] &
                       reg_data$slugTeam == reg_data$slugTeam[i] &
                       reg_data$days < reg_data$days[i] &
                       reg_data$idPlayer == reg_data$idPlayer[i],]
  # If any exist
  if(nrow(temp_1) > 0){
    # Calculate previous averages
    t1 <- temp_1[, c("fgm", "fga", "fg3m", "fg3a", "fg2m",
                                                         "fg2a", "ftm", "fta", "oreb", "dreb",
                                                         "treb", "ast", "stl", "blk", "tov",
                                                         "pf", "pts")]/temp_1$minutes
  
  off[i, c("fgm", "fga", "fg3m", "fg3a", "fg2m",
           "fg2a", "ftm", "fta", "oreb", "dreb",
           "treb", "ast", "stl", "blk", "tov",
           "pf", "pts")] <- colMeans(t1, na.rm = TRUE)
  off[i, c("mins")] <- mean(temp_1$minutes)
  off[i,c("games")] <- nrow(temp_1)
  # Calculate pctfg, pctfg2 pctfg3, pctft
  off$pctfg[i] <- sum(temp_1$fgm, na.rm = TRUE)/sum(temp_1$fga, na.rm = TRUE)
  off$pctfg2[i] <- sum(temp_1$fg2m, na.rm = TRUE)/sum(temp_1$fg2a, na.rm = TRUE)
  off$pctfg3[i] <- sum(temp_1$fg3m, na.rm = TRUE)/sum(temp_1$fg3a, na.rm = TRUE)
  off$pctft[i] <- sum(temp_1$ftm, na.rm = TRUE)/sum(temp_1$fta, na.rm = TRUE)
    
    

  }
  
  player_games <- reg_data[reg_data$idPlayer == reg_data$idPlayer[i], c("idGame", "minutes")]
  # Extract previous games for team 1 defense
  temp_2 <- team_game[team_game$slugSeason == reg_data$slugSeason[i] &
                        team_game$slugOpponent == reg_data$slugTeam[i] &
                        team_game$days < reg_data$days[i],]
  # If any exist
  if(nrow(temp_2) > 0 &
     sum(temp_2$idGame %in% player_games$idGame) > 0){
    
    stats <- temp_2[, c("fgm", "fga", "fg3m", "fg3a", "fg2m",
                        "fg2a", "ftm", "fta", "oreb", "dreb",
                        "treb", "ast", "stl", "blk", "tov",
                        "pf", "pts")]
    
    game_mins <- rep(NA, nrow(temp_2))
    for(j in 1:nrow(temp_2)){
      if(temp_2$idGame[j] %in% player_games$idGame){
        game_mins[j] <- player_games$minutes[which(player_games$idGame == temp_2$idGame[j])]
      }
      
    }
    
    
    stats_use <- stats[!is.na(game_mins),]
    game_mins_use <- game_mins[!is.na(game_mins)]
    stats_avg <- stats_use/game_mins_use
    # Calculate past defensive averages
    def[i,c("fgm", "fga", "fg3m", "fg3a", "fg2m",
           "fg2a", "ftm", "fta", "oreb", "dreb",
           "treb", "ast", "stl", "blk", "tov",
           "pf", "pts")] <- colMeans(stats_avg, na.rm = T)
    
    # Calculate pctfg, pctfg2 pctfg3, pctft
    def$pctfg[i] <- sum(stats_use$fgm, na.rm = TRUE)/sum(stats_use$fga, na.rm = TRUE)
    def$pctfg2[i] <- sum(stats_use$fg2m, na.rm = TRUE)/sum(stats_use$fg2a, na.rm = TRUE)
    def$pctfg3[i] <- sum(stats_use$fg3m, na.rm = TRUE)/sum(stats_use$fg3a, na.rm = TRUE)
    def$pctft[i] <- sum(stats_use$ftm, na.rm = TRUE)/sum(stats_use$fta, na.rm = TRUE)

  }
}  
  
summary(def)
summary(off)


for(i in 1:ncol(off)){
  off[!is.finite(off[,i]),i] <- 0
  def[!is.finite(def[,i]),i] <- 0
}


names(off) <- paste(names(off), "_1_off", sep = "")
names(def) <- paste(names(def), "_1_def", sep = "")
res_dat <- cbind.data.frame(reg_data[,c("idGame", "nameTeam", "slugTeam", "slugOpponent",
                                        "idPlayer", "namePlayer")], 
                            off, def)

stat_player_mod <- function(playerid = NULL, gameid = NULL,
                            res_dat, game_data){
  #'
  #' This function subtracts a players stats from the game
  #' and replaces them with the stats of an average player.
  #'
  #' @param playerid The player ID of interest
  #' @param gameid The game ID of interest
  #' @param res_dat The offensive/defensive player stats
  #' gae
  #' 
  #' 
  #'
  
  player_data_index_1 <- which(res_dat$idGame == gameid &
                               res_dat$idPlayer == playerid)
  
  game_data_index_1 <- which(game_data$idGame == gameid & 
                               game_data$slugTeam == res_dat$slugTeam[player_data_index_1])
  
  game_data_index_2 <- which(game_data$idGame == gameid & 
                               game_data$slugTeam == res_dat$slugOpponent[player_data_index_1])
  
  cols1 <- c("fgm_1_off", "fga_1_off",   
            "fg3m_1_off", "fg3a_1_off", "fg2m_1_off", "fg2a_1_off", "ftm_1_off", "fta_1_off", "oreb_1_off",  
            "dreb_1_off", "treb_1_off", "ast_1_off", "stl_1_off", "blk_1_off", "tov_1_off", "pf_1_off",    
            "pts_1_off",    "pctfg_1_off",  "pctfg2_1_off", "pctfg3_1_off", "pctft_1_off", 
            "fgm_1_def",    "fga_1_def",    "fg3m_1_def",   "fg3a_1_def", 
            "fg2m_1_def",   "fg2a_1_def", "ftm_1_def",   
            "fta_1_def",    "oreb_1_def",   "dreb_1_def",
            "treb_1_def",   "ast_1_def",    "stl_1_def",    "blk_1_def",   
            "tov_1_def",    "pf_1_def",     "pts_1_def",    "pctfg_1_def",
            "pctfg2_1_def", "pctfg3_1_def", "pctft_1_def")
  
  cols2 <- c("fgm_2_off", "fga_2_off",   
             "fg3m_2_off", "fg3a_2_off", "fg2m_2_off", "fg2a_2_off", "ftm_2_off", "fta_2_off", "oreb_2_off",  
             "dreb_2_off", "treb_2_off", "ast_2_off", "stl_2_off", "blk_2_off", "tov_2_off", "pf_2_off",    
             "pts_2_off",    "pctfg_2_off",  "pctfg2_2_off", "pctfg3_2_off", "pctft_2_off", 
             "fgm_2_def",    "fga_2_def",    "fg3m_2_def",   "fg3a_2_def", 
             "fg2m_2_def",   "fg2a_2_def", "ftm_2_def",   
             "fta_2_def",    "oreb_2_def",   "dreb_2_def",
             "treb_2_def",   "ast_2_def",    "stl_2_def",    "blk_2_def",   
             "tov_2_def",    "pf_2_def",     "pts_2_def",    "pctfg_2_def",
             "pctfg2_2_def", "pctfg3_2_def", "pctft_2_def")

 
  
  
  team_stats <- game_data[game_data_index_1, cols1] 
  
  m_vec <- c("fgm_1_off", "fga_1_off",   
             "fg3m_1_off", "fg3a_1_off", "fg2m_1_off", "fg2a_1_off", "ftm_1_off", "fta_1_off", "oreb_1_off",  
             "dreb_1_off", "treb_1_off", "ast_1_off", "stl_1_off", "blk_1_off", "tov_1_off", "pf_1_off",    
             "pts_1_off","fgm_1_def",    "fga_1_def",    "fg3m_1_def",   "fg3a_1_def", 
             "fg2m_1_def",   "fg2a_1_def", "ftm_1_def",   
             "fta_1_def",    "oreb_1_def",   "dreb_1_def",
             "treb_1_def",   "ast_1_def",    "stl_1_def",    "blk_1_def",   
             "tov_1_def",    "pf_1_def",     "pts_1_def")
  
  m_stats <- colMeans(res_dat[res_dat$mins_1_off > 25,m_vec], na.rm =TRUE)

  team_stats[,m_vec] <- team_stats[,m_vec] - 
    (res_dat[player_data_index_1, m_vec] * res_dat$mins_1_off[player_data_index_1]) + 
    (m_stats[m_vec] * res_dat$mins_1_off[player_data_index_1]) 
  
  # Recalculate averages
  team_stats$pctfg_1_off <- team_stats$fgm_1_off/team_stats$fga_1_off
  team_stats$pctfg2_1_off <- team_stats$fg2m_1_off/team_stats$fg2a_1_off
  team_stats$pctfg3_1_off<- team_stats$fg3m_1_off/team_stats$fg3m_1_off
  team_stats$pctft_1_off <- team_stats$ftm_1_off/team_stats$fta_1_off
  team_stats$pctfg_1_def <- team_stats$fgm_1_def/team_stats$fga_1_def
  team_stats$pctfg2_1_def <- team_stats$fg2m_1_def/team_stats$fg2a_1_def
  team_stats$pctfg3_1_def<- team_stats$fg3m_1_def/team_stats$fg3m_1_def
  team_stats$pctft_1_def <- team_stats$ftm_1_def/team_stats$fta_1_def
  
  # Assign to team 1
  game_data[game_data_index_1, cols1] <- team_stats
  game_data[game_data_index_2, cols2] <- team_stats
  
  return(game_data)
} 



game_data[1500,]

res_dat[res_dat$idGame == 21900499,]

# Input player ID, and game ID of interest
game_data_2 <- stat_player_mod(playerid = 202331,
                               gameid = 21900499,
                               res_dat = res_dat, 
                               game_data = game_data)


rbind(game_data[game_data$idGame == 21900499,],

game_data_2[game_data$idGame == 21900499,])
```



```{r}
stat_player_replace <- function(playerid_1 = NULL, playerid_2 = NULL,
                            res_dat, game_data){
  #'
  #' This function subtracts a players stats from the game
  #' and replaces them with the stats of an average player.
  #'
  #' @param playerid_1 The player ID to be replaced
  #' @param playerid_2 The player ID to use as replacement
  #' @param res_dat The offensive/defensive player stats
  #' @param game_data The game level data
  #' 
  #' 
  #'
  
  # Identify first player games
  player_data_index_1 <- which(res_dat$idPlayer == playerid_1)
  # Identify second player games
  player_data_index_2 <- which(res_dat$idPlayer == playerid_2)
  # Find games of interest
  game_data_index_1 <- which(game_data$slugTeam == res_dat$slugTeam[player_data_index_1[1]])
  # Find games where team is opponent
  game_data_index_2 <- which(game_data$slugTeam == res_dat$slugOpponent[player_data_index_1[1]])
  
  # Create vectors of columns to use
  cols1 <- c("fgm_1_off", "fga_1_off",   
            "fg3m_1_off", "fg3a_1_off", "fg2m_1_off", "fg2a_1_off", "ftm_1_off", "fta_1_off", "oreb_1_off",  
            "dreb_1_off", "treb_1_off", "ast_1_off", "stl_1_off", "blk_1_off", "tov_1_off", "pf_1_off",    
            "pts_1_off",    "pctfg_1_off",  "pctfg2_1_off", "pctfg3_1_off", "pctft_1_off", 
            "fgm_1_def",    "fga_1_def",    "fg3m_1_def",   "fg3a_1_def", 
            "fg2m_1_def",   "fg2a_1_def", "ftm_1_def",   
            "fta_1_def",    "oreb_1_def",   "dreb_1_def",
            "treb_1_def",   "ast_1_def",    "stl_1_def",    "blk_1_def",   
            "tov_1_def",    "pf_1_def",     "pts_1_def",    "pctfg_1_def",
            "pctfg2_1_def", "pctfg3_1_def", "pctft_1_def")
  
  cols2 <- c("fgm_2_off", "fga_2_off",   
             "fg3m_2_off", "fg3a_2_off", "fg2m_2_off", "fg2a_2_off", "ftm_2_off", "fta_2_off", "oreb_2_off",  
             "dreb_2_off", "treb_2_off", "ast_2_off", "stl_2_off", "blk_2_off", "tov_2_off", "pf_2_off",    
             "pts_2_off",    "pctfg_2_off",  "pctfg2_2_off", "pctfg3_2_off", "pctft_2_off", 
             "fgm_2_def",    "fga_2_def",    "fg3m_2_def",   "fg3a_2_def", 
             "fg2m_2_def",   "fg2a_2_def", "ftm_2_def",   
             "fta_2_def",    "oreb_2_def",   "dreb_2_def",
             "treb_2_def",   "ast_2_def",    "stl_2_def",    "blk_2_def",   
             "tov_2_def",    "pf_2_def",     "pts_2_def",    "pctfg_2_def",
             "pctfg2_2_def", "pctfg3_2_def", "pctft_2_def")
  
  
   m_vec <- c("fgm_1_off", "fga_1_off",   
             "fg3m_1_off", "fg3a_1_off", "fg2m_1_off", "fg2a_1_off", "ftm_1_off", "fta_1_off", "oreb_1_off",  
             "dreb_1_off", "treb_1_off", "ast_1_off", "stl_1_off", "blk_1_off", "tov_1_off", "pf_1_off",    
             "pts_1_off","fgm_1_def",    "fga_1_def",    "fg3m_1_def",   "fg3a_1_def", 
             "fg2m_1_def",   "fg2a_1_def", "ftm_1_def",   
             "fta_1_def",    "oreb_1_def",   "dreb_1_def",
             "treb_1_def",   "ast_1_def",    "stl_1_def",    "blk_1_def",   
             "tov_1_def",    "pf_1_def",     "pts_1_def")
   
   # Calculate mean stats for replacement player
    m_stats <- colMeans(res_dat[player_data_index_2,m_vec], na.rm =TRUE)
    
    
    # For each game
  for(i in 1:length(game_data_index_1)){
    # Extract game stats
     team_stats <- game_data[game_data_index_1[i], cols1] 
     # If game stats are not missing from first week of the season
     if(!is.na(team_stats$fgm_1_off[1])){
       
       # Set new stats as 
       team_stats[,m_vec] <- team_stats[,m_vec] - # Current team stats
         # Minus player to be removed stats * minutes played
    (res_dat[player_data_index_1[i], m_vec] * res_dat$mins_1_off[player_data_index_1[i]]) + 
         # Player 2 average stats * minutes played by player 1
    (m_stats[m_vec] * res_dat$mins_1_off[player_data_index_1[i]]) 
     
     # Recalculate averages
  team_stats$pctfg_1_off <- team_stats$fgm_1_off/team_stats$fga_1_off
  team_stats$pctfg2_1_off <- team_stats$fg2m_1_off/team_stats$fg2a_1_off
  team_stats$pctfg3_1_off<- team_stats$fg3m_1_off/team_stats$fg3m_1_off
  team_stats$pctft_1_off <- team_stats$ftm_1_off/team_stats$fta_1_off
  team_stats$pctfg_1_def <- team_stats$fgm_1_def/team_stats$fga_1_def
  team_stats$pctfg2_1_def <- team_stats$fg2m_1_def/team_stats$fg2a_1_def
  team_stats$pctfg3_1_def<- team_stats$fg3m_1_def/team_stats$fg3m_1_def
  team_stats$pctft_1_def <- team_stats$ftm_1_def/team_stats$fta_1_def
  
  # Assign to team 1
  game_data[game_data_index_1[i], cols1] <- team_stats
  game_data[game_data_index_2[i], cols2] <- team_stats
     }
     
  }

  return(game_data)
} 


temp <- unique(reg_data[, c("namePlayer", "idPlayer")])

game_data_3 <- na.omit(game_data_3)

# Create new column for point differential

game_data_3$point_dif <- game_data_3$team_1_points - game_data_3$team_2_points
```





```{r}

# Excludes each team's first game of the year, as no previous stats exist to predict outcome

game_data <- na.omit(game_data)

# Create new column for point differential

game_data$point_dif <- game_data$team_1_points - game_data$team_2_points

# Split data into training and test sets

set.seed(1)

dt = sort(sample(nrow(game_data), nrow(game_data)*.8))
train_data <- game_data[dt,]
test_data <- game_data[-dt,]

head(train_data)
dim(train_data)
```

```{r}


train_data$outcomeGame <- as.factor(train_data$outcomeGame)
```



```{r}

library(caret)

library(randomForest)

set.seed(1) # Set random number generator seed for reproducability
# Use random forest to do bagging
bag_mod <- randomForest(outcomeGame ~., # Set tree formula
                data = train_data[,7:91], # Set dataset
                mtry = 86, # Set mtry to number of variables 
                ntree = 200) # Set number of trees to use
bag_mod # View model


bag_preds <- predict(bag_mod, test_data) # Create predictions for bagging model

t <- table(bag_preds,test_data$outcome) # Create table
confusionMatrix(t,  positive = "W") # Produce confusion matrix
```


```{r}
# Extract Importance
importance_matrix <- randomForest::importance(bag_mod)

# Order and print importance matrix

importance_matrix <- importance_matrix[order(importance_matrix, decreasing = T), ]

importance_matrix
```

```{r}
head(game_data)
```


```{r}

library(xgboost)

# Create training matrix
dtrain <- xgb.DMatrix(data = as.matrix(train_data[, -c((1:7),(92:94))]), label = train_data$point_dif)
# Create test matrix
dtest <- xgb.DMatrix(data = as.matrix(test_data[, -c((1:7),(92:94))]), label = test_data$point_dif)
```




```{r}

set.seed(2374)

bst_1 <- xgboost(data = dtrain, # Set training data

               

               nrounds = 100, # Set number of rounds

               

               verbose = 1, # 1 - Prints out fit

                print_every_n = 20# Prints out result every 20th iteration

 ) 
```

### Predicting with XGBoost




```{r xbgoost predictions_1}
library(Metrics)

bst_preds_1 <- predict(bst_1, dtest) # Create predictions for xgboost model

bst_1_rmse <- rmse(actual = test_data$point_dif, predicted = bst_preds_1)

bst_1_rmse
```



**Parameter Tuning**

```{r xgboost param tuning}
# Use xgb.cv to run cross-validation inside xgboost
set.seed(2374)
bst <- xgb.cv(data = dtrain, # Set training data
              
              nfold = 5, # Use 5 fold cross-validation
               
               eta = 0.1, # Set learning rate
              
               nrounds = 1000, # Set number of rounds
               early_stopping_rounds = 50, # Set number of rounds to stop at if there is no improvement
               
               verbose = 1, # 1 - Prints out fit
               nthread = 1, # Set number of parallel threads
               print_every_n = 20) # Prints out result every 20th iteration
```


**Maximum Depth & Minimum Child Weight Tuning**

```{r tune xgb params 1}
# Be Careful - This can take a very long time to run
max_depth_vals <- c(3, 5, 7, 10, 15) # Create vector of max depth values
min_child_weight <- c(1,3,5,7, 10, 15) # Create vector of min child values

# Expand grid of parameter values
cv_params <- expand.grid(max_depth_vals, min_child_weight)
names(cv_params) <- c("max_depth", "min_child_weight")
# Create results vector
rmse_vec <- rep(NA, nrow(cv_params))
```


```{r tune xgb params 2}
# Loop through results
for(i in 1:nrow(cv_params)){
  set.seed(2374)
  bst_tune <- xgb.cv(data = dtrain, # Set training data
        
    nfold = 5, # Use 5 fold cross-validation
               
    eta = 0.1, # Set learning rate
    max.depth = cv_params$max_depth[i], # Set max depth
    min_child_weight = cv_params$min_child_weight[i], # Set minimum number of samples in node to split
             
               
    nrounds = 500, # Set number of rounds
    early_stopping_rounds = 50, # Set number of rounds to stop at if there is no improvement
               
    verbose = 1, # 1 - Prints out fit
    nthread = 1, # Set number of parallel threads
    print_every_n = 20,
    eval_metric = "rmse") # Prints out result every 20th iteration
               

  rmse_vec[i] <- bst_tune$evaluation_log$test_rmse_mean[bst_tune$best_ntreelimit]

}

```


```{r Visualise Tune 1}
# Join results in dataset
res_db <- cbind.data.frame(cv_params, rmse_vec)
names(res_db)[3] <- c("rmse") 
res_db$max_depth <- as.factor(res_db$max_depth) # Convert tree number to factor for plotting
res_db$min_child_weight <- as.factor(res_db$min_child_weight) # Convert node size to factor for plotting
# Print RMSE heatmap
g_2 <- ggplot(res_db, aes(y = max_depth, x = min_child_weight, fill = rmse)) + # set aesthetics
  geom_tile() + # Use geom_tile for heatmap
  theme_bw() + # Set theme
  scale_fill_gradient2(low = "blue", # Choose low color
    mid = "white", # Choose mid color
    high = "red", # Choose high color
    midpoint =mean(res_db$rmse), # Choose mid point
    space = "Lab", 
    na.value ="grey", # Choose NA value
    guide = "colourbar", # Set color bar
    aesthetics = "fill") + # Select aesthetics to apply
  labs(title = "RMSE", x = "Minimum Child Weight", y = "Max Depth", fill = "Scale") # Set labels
g_2 # Generate plot
```


**Gamma Tuning**

```{r gamma tuning}
gamma_vals <- c(0, 0.05, 0.1, 0.15, 0.2) # Create vector of gamma values

# Be Careful - This can take a very long time to run
set.seed(2374)
# Create results vector
rmse_vec_2  <- rep(NA, length(gamma_vals))
for(i in 1:length(gamma_vals)){
  bst_tune_2 <- xgb.cv(data = dtrain, # Set training data
              
              nfold = 5, # Use 5 fold cross-validation
               
              eta = 0.1, # Set learning rate
              max.depth = 3, # Set max depth
              min_child_weight = 10, # Set minimum number of samples in node to split
              gamma = gamma_vals[i], # Set minimum loss reduction for split

              
               
              nrounds = 500, # Set number of rounds
              early_stopping_rounds = 50, # Set number of rounds to stop at if there is no improvement
               
              verbose = 1, # 1 - Prints out fit
              nthread = 1, # Set number of parallel threads
              print_every_n = 20, # Prints out result every 20th iteration
               
              eval_metric = "rmse") # Prints out result every 20th iteration
               

  rmse_vec_2[i] <- bst_tune_2$evaluation_log$test_rmse_mean[bst_tune$best_ntreelimit]

}
```
The gamma with the lowest test-rmse is 0.05


```{r tune xgb samples}

# Be Careful - This can take a very long time to run
subsample <- c(0.6, 0.7, 0.8, 0.9, 1) # Create vector of subsample values
colsample_by_tree <- c(0.6, 0.7, 0.8, 0.9, 1) # Create vector of col sample values

# Expand grid of tuning parameters
cv_params_3 <- expand.grid(subsample, colsample_by_tree)
names(cv_params_3) <- c("subsample", "colsample_by_tree")
# Create results vector
rmse_vec_3 <-  rep(NA, nrow(cv_params_3))
# Loop through parameter values
for(i in 1:nrow(cv_params_3)){
  set.seed(2374)
  bst_tune_3 <- xgb.cv(data = dtrain, # Set training data
              
              nfold = 5, # Use 5 fold cross-validation
               
              eta = 0.1, # Set learning rate
              max.depth = 3, # Set max depth
              min_child_weight = 10, # Set minimum number of samples in node to split
              gamma = 0.05, # Set minimum loss reduction for split
              subsample = cv_params_3$subsample[i], # Set proportion of training data to use in tree
              colsample_bytree = cv_params_3$colsample_by_tree[i], # Set number of variables to use in each tree
               
              nrounds = 500, # Set number of rounds
              early_stopping_rounds = 50, # Set number of rounds to stop at if there is no improvement
               
              verbose = 1, # 1 - Prints out fit
              nthread = 1, # Set number of parallel threads
              print_every_n = 20, # Prints out result every 20th iteration
               
              eval_metric = "rmse") # Prints out result every 20th iteration
               

  rmse_vec_3[i] <- bst_tune_3$evaluation_log$test_rmse_mean[bst_tune_3$best_ntreelimit]
}
  
```



```{r Visualise Tune 2}
# Join results in dataset
res_db_3 <- cbind.data.frame(cv_params_3, rmse_vec_3)
names(res_db_3)[3] <- c("rmse") 
res_db_3$colsample_by_tree <- as.factor(res_db_3$colsample_by_tree) # Convert tree number to factor for plotting
res_db_3$subsample <- as.factor(res_db_3$subsample) # Convert node size to factor for plotting
# Print RMSE heatmap
g_5 <- ggplot(res_db_3, aes(y = colsample_by_tree, x = subsample, fill = rmse)) + # set aesthetics
  geom_tile() + # Use geom_tile for heatmap
  theme_bw() + # Set theme
  scale_fill_gradient2(low = "blue", # Choose low color
    mid = "white", # Choose mid color
    high = "red", # Choose high color
    midpoint =mean(res_db$rmse), # Choose mid point
    space = "Lab", 
    na.value ="grey", # Choose NA value
    guide = "colourbar", # Set color bar
    aesthetics = "fill") + # Select aesthetics to apply
  labs(title = "RMSE", x = "Subsample", y = "Column Sample", fill = "Scale") # Set labels
g_5 # Generate plot

```



**eta Tuning**

```{r eta tuning}

# Use xgb.cv to run cross-validation inside xgboost
set.seed(2374)
bst_mod_1 <- xgb.cv(data = dtrain, # Set training data
              
              nfold = 5, # Use 5 fold cross-validation
               
              eta = 0.3, # Set learning rate
              max.depth = 3, # Set max depth
              min_child_weight = 10, # Set minimum number of samples in node to split
              gamma = 0.15, # Set minimum loss reduction for split
              subsample = 1, # Set proportion of training data to use in tree
              colsample_bytree = 0.6, # Set number of variables to use in each tree
               
              nrounds = 1000, # Set number of rounds
              early_stopping_rounds = 20, # Set number of rounds to stop at if there is no improvement
               
              verbose = 1, # 1 - Prints out fit
              nthread = 1, # Set number of parallel threads
              print_every_n = 20, # Prints out result every 20th iteration
              

              eval_metric = "rmse") # Prints out result every 20th iteration


set.seed(2374) 
bst_mod_2 <- xgb.cv(data = dtrain, # Set training data
              
              nfold = 5, # Use 5 fold cross-validation
               
              eta = 0.1, # Set learning rate
              max.depth = 3, # Set max depth
              min_child_weight = 10, # Set minimum number of samples in node to split
              gamma = 0.15, # Set minimum loss reduction for split
              subsample = 1, # Set proportion of training data to use in tree
              colsample_bytree = 0.6, # Set number of variables to use in each tree
               
              nrounds = 1000, # Set number of rounds
              early_stopping_rounds = 20, # Set number of rounds to stop at if there is no improvement
               
              verbose = 1, # 1 - Prints out fit
              nthread = 1, # Set number of parallel threads
              print_every_n = 20, # Prints out result every 20th iteration
              
              eval_metric = "rmse") # Prints out result every 20th iteration


set.seed(2374)
bst_mod_3 <- xgb.cv(data = dtrain, # Set training data
              
              nfold = 5, # Use 5 fold cross-validation
               
              eta = 0.05, # Set learning rate
              max.depth = 3, # Set max depth
              min_child_weight = 10, # Set minimum number of samples in node to split
              gamma = 0.15, # Set minimum loss reduction for split
              subsample = 1, # Set proportion of training data to use in tree
              colsample_bytree = 0.6, # Set number of variables to use in each tree
               
              nrounds = 1000, # Set number of rounds
              early_stopping_rounds = 20, # Set number of rounds to stop at if there is no improvement
               
              verbose = 1, # 1 - Prints out fit
              nthread = 1, # Set number of parallel threads
              print_every_n = 20, # Prints out result every 20th iteration
              
     
              eval_metric = "rmse") # Prints out result every 20th iteration


set.seed(2374)
bst_mod_4 <- xgb.cv(data = dtrain, # Set training data
              
              nfold = 5, # Use 5 fold cross-validation
               
              eta = 0.01, # Set learning rate
              max.depth = 3, # Set max depth
              min_child_weight = 10, # Set minimum number of samples in node to split
              gamma = 0.15, # Set minimum loss reduction for split
              subsample = 1, # Set proportion of training data to use in tree
              colsample_bytree = 0.6, # Set number of variables to use in each tree
              
              nrounds = 1000, # Set number of rounds
              early_stopping_rounds = 20, # Set number of rounds to stop at if there is no improvement
               
              verbose = 1, # 1 - Prints out fit
              nthread = 1, # Set number of parallel threads
              print_every_n = 20, # Prints out result every 20th iteration
              

              eval_metric = "rmse") # Prints out result every 20th iteration

set.seed(2374)
bst_mod_5 <- xgb.cv(data = dtrain, # Set training data
              
              nfold = 5, # Use 5 fold cross-validation
               
              eta = 0.005, # Set learning rate
              max.depth = 3, # Set max depth
              min_child_weight = 10, # Set minimum number of samples in node to split
              gamma = 0.15, # Set minimum loss reduction for split
              subsample = 1, # Set proportion of training data to use in tree
              colsample_bytree = 0.6, # Set number of variables to use in each tree
               
              nrounds = 1000, # Set number of rounds
              early_stopping_rounds = 20, # Set number of rounds to stop at if there is no improvement
               
              verbose = 1, # 1 - Prints out fit
              nthread = 1, # Set number of parallel threads
              print_every_n = 20, # Prints out result every 20th iteration
               
      
              eval_metric = "rmse") # Prints out result every 20th iteration
```

We can then plot the error rate over different learning rates:

```{r eta plots}

# Extract results for model with eta = 0.3
pd1 <- cbind.data.frame(bst_mod_1$evaluation_log[,c("iter", "test_rmse_mean")], rep(0.3, nrow(bst_mod_1$evaluation_log)))
names(pd1)[3] <- "eta"
# Extract results for model with eta = 0.1
pd2 <- cbind.data.frame(bst_mod_2$evaluation_log[,c("iter", "test_rmse_mean")], rep(0.1, nrow(bst_mod_2$evaluation_log)))
names(pd2)[3] <- "eta"
# Extract results for model with eta = 0.05
pd3 <- cbind.data.frame(bst_mod_3$evaluation_log[,c("iter", "test_rmse_mean")], rep(0.05, nrow(bst_mod_3$evaluation_log)))
names(pd3)[3] <- "eta"
# Extract results for model with eta = 0.01
pd4 <- cbind.data.frame(bst_mod_4$evaluation_log[,c("iter", "test_rmse_mean")], rep(0.01, nrow(bst_mod_4$evaluation_log)))
names(pd4)[3] <- "eta"
# Extract results for model with eta = 0.005
pd5 <- cbind.data.frame(bst_mod_5$evaluation_log[,c("iter", "test_rmse_mean")], rep(0.005, nrow(bst_mod_5$evaluation_log)))
names(pd5)[3] <- "eta"
# Join datasets
plot_data <- rbind.data.frame(pd1, pd2, pd3, pd4, pd5)
# Converty ETA to factor
plot_data$eta <- as.factor(plot_data$eta)
# Plot points
g_8 <- ggplot(plot_data, aes(x = iter, y = test_rmse_mean, color = eta))+
  geom_point(alpha = 0.5) +
  theme_bw() + # Set theme
  theme(panel.grid.major = element_blank(), # Remove grid
        panel.grid.minor = element_blank(), # Remove grid
        panel.border = element_blank(), # Remove grid
        panel.background = element_blank()) + # Remove grid 
  labs(x = "Number of Trees", title = "RMSE v Number of Trees",
       y = "RMSE", color = "Learning \n Rate")  # Set labels
g_8

# Plot lines
g_9 <- ggplot(plot_data, aes(x = iter, y = test_rmse_mean, color = eta))+
  geom_smooth(alpha = 0.5) +
  theme_bw() + # Set theme
  theme(panel.grid.major = element_blank(), # Remove grid
        panel.grid.minor = element_blank(), # Remove grid
        panel.border = element_blank(), # Remove grid
        panel.background = element_blank()) + # Remove grid 
  labs(x = "Number of Trees", title = "RMSE v Number of Trees",
       y = "RMSE", color = "Learning \n Rate")  # Set labels
g_9

```


```{r}
# Tuned Model 

set.seed(2374)
bst_mod_final <- xgboost(data = dtrain, # Set training data
              
              nfold = 5, # Use 5 fold cross-validation
               
              eta = 0.1, # Set learning rate
              max.depth = 3, # Set max depth
              min_child_weight = 10, # Set minimum number of samples in node to split
              gamma = 0.05, # Set minimum loss reduction for split
              subsample = 1, # Set proportion of training data to use in tree
              colsample_bytree = 0.6, # Set number of variables to use in each tree
               
              nrounds = 1000, # Set number of rounds
              early_stopping_rounds = 20, # Set number of rounds to stop at if there is no improvement
               
              verbose = 1, # 1 - Prints out fit
              nthread = 1, # Set number of parallel threads
              print_every_n = 20, # Prints out result every 20th iteration
              

              eval_metric = "rmse") # Prints out result every 20th iteration

```


```{r}
bst_preds_final <- predict(bst_mod_final, dtest) # Create predictions for xgboost model


```


```{r}
bst_final_rmse <- rmse(actual = test_data$point_dif, predicted = bst_preds_final)

bst_final_rmse
```

```{r}
# Extract importance
imp_mat <- xgb.importance(model = bst_mod_final)
# Plot importance (top 10 variables)
xgb.plot.importance(imp_mat, top_n = 10)
```





##### Switch out Players

```{r}
# Create table of player IDs
temp <- unique(reg_data[, c("namePlayer", "idPlayer")])
# View player IDs
temp
```


```{r}


# Replace KCP with westbrook
game_data_3 <- stat_player_replace(playerid_1 = 203484,  # Old player - KCP
                playerid_2 = 201566, # New player - Westbrook
                res_dat, game_data)

# Find games for Lakers
la_games <- game_data$idGame[game_data$slugTeam == "LAL"]

# Create dtest for lakers games
dtest_l2020 <- xgb.DMatrix(data = as.matrix(game_data[game_data$idGame %in% lal_games &
                                                        game_data$slugTeam == "LAL", -c((1:7),(92:94))]), label = game_data$point_dif[game_data$idGame %in% lal_games &
                                                        game_data$slugTeam == "LAL"])

# Create dtest for lakers games with Westbrook replacing KCP
dtest_l2020_w <- xgb.DMatrix(data = as.matrix(game_data_3[game_data_3$idGame %in% lal_games &
                                                        game_data_3$slugTeam == "LAL", -c((1:7),(92:94))]), label = game_data_3$point_dif[game_data_3$idGame %in% lal_games &
                                                        game_data_3$slugTeam == "LAL"])
```

```{r}
# Create predictions
bst_preds_final_l2020 <- predict(bst_mod_final, dtest_l2020)
bst_preds_final_l2020_w <- predict(bst_mod_final, dtest_l2020_w)
```

```{r}
# Create predictions table with game info
res_table <- cbind.data.frame(game_data[game_data$idGame %in% lal_games & game_data$slugTeam == "LAL",c("yearSeason"    ,"slugTeam","slugOpponent",  "outcomeGame")], bst_preds_final_l2020,bst_preds_final_l2020_w  )
# View predictions table
res_table
```

```{r}
# Calculate predicted wins
wins <- sum(bst_preds_final_l2020 > 0)
wins_w_westbrook <- sum(bst_preds_final_l2020_w > 0)
# View wins
wins
wins_w_westbrook
# Calculate win percentage
wins/length(bst_preds_final_l2020)
wins_w_westbrook/length(bst_preds_final_l2020_w)
```

```{r}
# Calculate actual wins in 2021
wins_acc <- sum(res_table$outcomeGame[res_table$yearSeason == 2021] == "W")

# Calculate predicted win percentage for 2021
wins <- sum(bst_preds_final_l2020[res_table$yearSeason == 2021] > 0)
wins_w_westbrook <- sum(bst_preds_final_l2020_w[res_table$yearSeason == 2021] > 0)
# View wins for 2021
wins_acc
wins
wins_w_westbrook
# View predicted win percentage
wins_acc/sum(res_table$yearSeason == 2021)
wins/length(bst_preds_final_l2020[res_table$yearSeason == 2021])
wins_w_westbrook/length(bst_preds_final_l2020_w[res_table$yearSeason == 2021])
```

